---
title: "Server Aided MLS"
abbrev: "SA-MLS"
category: info

docname: draft-mularczyk-mls-splitcommit-latest
submissiontype: IETF  # also: "independent", "editorial", "IAB", or "IRTF"
number:
date:
consensus: true
v: 3
area: "Security"
workgroup: "Messaging Layer Security"
keyword:
 - next generation
 - unicorn
 - sparkling distributed ledger
venue:
  group: "Messaging Layer Security"
  type: "Working Group"
  mail: "mls@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/browse/mls/"
  github: "beurdouche/ietf-mularczyk-mls-splitcommit"
  latest: "https://beurdouche.github.io/ietf-mularczyk-mls-splitcommit/draft-mularczyk-mls-splitcommit.html"

author:
 -
    fullname: Marta Mularczyk
    organization: AWS Wickr
    email: mulmarta@amazon.com

normative:

informative:
  KKP22: DOI.10.1007/978-3-030-64837-4\_10
  HKPPW22: DOI.10.1145/3460120.3484817
  AHKM22: DOI.10.1145/3548606.3560632

--- abstract

Splittable commits are an extension to the MLS protocol {{!RFC940}} that
improves its efficiency by reducing the amount of data members must download at
no cost. In particular, it is compatible with any Delivery Service (although for
some DS's the efficiency may be the same as for MLS).

The extension defines two new message types: splittable commits and individual
commits. Together they replace regular MLS commits. A splittable commit is
generated by a committer. It is similar to an MLS commit, but unlike the latter,
it can be split up into much smaller individual commits; one for each receiving
member. The size of an individual commit is (at most) logarithmic in the group
size, while the size of a regular MLS commit can reach linear.

Splitting can be done by the DS, the committer or even a receiver. This makes it
ideal for settings with a central DS and point-to-point channels (where the
committer splits).

The extension is based on academic research {{KKP22}}, {{HKPPW22}}, {{AHKM22}}.


--- middle

# Introduction

## Protocol Overview

The Splittable Commits MLS extension restructures commits to allow a group
member to only download the minimal information about a commit needed to process
it. The following scenario examplifies the redundant data in a regular MLS
Commit which this extension drops.

Consider the example ratchet tree from {{Section 7.4 of !RFC9420}}:

~~~~~
      Y
      |
    .-+-.
   /     \
  X       Z[C]
 / \     / \
A   B   C   D

0   1   2   3
~~~~~
{: #evolution-tree title="A Full Tree with One Unmerged Leaf" }

In an MLS group with a ratchet tree of this form, a commit by member 0 includes
computing two updated path secrets X' and Y', two new public keys for nodes X
and Y and three HPKE ciphertexts:

1. X' encrypted to B
2. Y' encrypted to Z
3. Y' encrypted to C

An MLS's regular Commit message includes both new public keys and ciphertexts
which is then all downloaded by each member. Yet, each receiver decrypts no more
than one of the ciphertexts and can compute at least one (or even two, for
member 1) of the new public keys themselves. Therefore, a substantial amount of
the downloaded data ends up being redundnat.

Instead, using this extension's individual commit messages, each member
receives only the one ciphertext they will actually decrypt and only the new
public keys they cannot re-derive on their own. One way to do this (e.g. when
the DS is not tracking the ratchet tree for the group) is for the committer to
directly create and send the individual commit messages. Alternatively, the
committer can create a single large commit message containing all ciphertexts
and new public keys. Then the DS can split the large commit into individual
commit messages for download by recipients.

In this extension, an individual commit is represented as an
IndividualCommit object while the large commits carrying all ciphertexts and
new public keys are represented as splittable commits, SCommit, objects.

~~~~~
A          B          C          D
| E(B; X') |          |          |
+--------->|          |          |
|          |          |          |
| E(C; Y') |          |          |
+-------------------->|          |
|          |          |          |
| E(D; Y') |          |          |
+------------------------------->|
|          |          |          |
~~~~~
{: #server-aided-direct title="A committer creates per-member commits" }

~~~~~
A          DS         B          C          D
| E(B; X') |          |          |          |
| E(C; Y') |          |          |          |
| E(D; Y') |          |          |          |
+--------->|          |          |          |
|          |          |          |          |
|          | E(B; X') |          |          |
|          +--------->|          |          |
|          |          |          |          |
|          | E(C; Y') |          |          |
|          +-------------------->|          |
|          |          |          |          |
|          | E(D; Y') |          |          |
|          +------------------------------->|
|          |          |          |          |
~~~~~
{: #server-aided-ds title="The DS creates per-member commits" }


# Conventions and Definitions

{::boilerplate bcp14-tagged}


# Splittable Commits

A splittable commit is represented as an SCommit object which consists of two
parts: a splittable update path and a header. The splittable update path,
SUpdatePath, is the MLS UpdatePath defined in {{!RFC9420}} but without the
committer's LeafNode. It is never encrypted, allowing the DS to split HPKE
public keys and ciphertexts it contains. The header, SHeader, contains
information delivered to all receivers: the committed list of proposals and the
committer's LeafNode and an epoch identifier. The header can be transmitted as
a Public or Private MLS Message.

A splittable commit can be split (by the DS or the committer) into
individual commits represented as IndividualCommit objects. An IndividualCommit
consists of the header SHeader and a part of the splittable update path.
The latter contains a single HPKE ciphertext and those new HPKE public keys that
the receiver cannot re-derive on their own.

~~~ tls-presentation
struct {
    ProposalOrRef proposals<V>;
    optional<LeafNode> leaf_node;
    opaque epoch_identifier<V>;
} SHeader;

struct {
    UpdatePathNode nodes<V>;
} SUpdatePath;

struct {
   HPKECiphertext encrypted_path_secret;
   HPKPublicKey<V> new_pks;
} IndividualUpdatePath;

struct {
    MLSMessage sheader; /* PrivateMessage or PublicMessage containing SHeader */
    optional<SUpdatePath> path;
} SCommit;

struct {
    MLSMessage sheader; /* PrivateMessage or PublicMessage containing SHeader */
    optional<IndividualUpdatePath> path;
} IndividualCommit;
~~~

To accomodate framing of SHeader objects, FramedContent and
FramedContentAuthData from {{!RFC9420}} are extended with a new content type
`sheader`.

~~~ tls-presentation
enum {
    /* the rest as in MLS */
    sheader(4),
    (255)
} ContentType;

struct {
    opaque group_id<V>;
    uint64 epoch;
    Sender sender;
    opaque authenticated_data<V>;

    ContentType content_type;
    select (FramedContent.content_type) {
        /* the rest as in MLS */
        case sheader:
          SHeader sheader;
    };
} FramedContent;

struct {
    opaque signature<V>;
    select (FramedContent.content_type) {
        case commit:
            MAC confirmation_tag;
        case application:
        case proposal:
        case sheader:
            struct{};
    };
} FramedContentAuthData;
~~~

Finally, an SCommit (or IndividualCommit) is sent by serializing it as an
MlsMessages. Accordingly, the MlsMessage is extended to accomodate the new
`mls_scommit` and `mls_individual_commit` content types.

~~~ tls-presentation
struct {
    ProtocolVersion version = mls10;
    WireFormat wire_format;
    select (MLSMessage.wire_format) {
        /* the rest as in MLS */
        case mls_scommit:
            SCommit scommit;
        case mls_individual_commit
            IndividualCommit
    };
} MLSMessage;
~~~

## Constructing Splittable Commits

A committing group member generates an SCommit using the following steps:

1. Perform a regular MLS Commit as described in Section 12.4 of {{!RFC9420}}.
   This a Commit object with `proposals` and `path`, where `path` consists of
   the committer's new `leaf_node` and its new direct path `nodes`. Use
   `proposals` and `path` to create the new epoch with the transcript hash
   computed as described in {Transcript Hashes}.
2. Generate the SHeader using the `proposals` and `leaf_node` from Step 1, and
   `epoch_identifier` exported from the new epoch's key schedule with the label
   "SplittableCommit".
3. Create an SUpdatePath using the `nodes` from Step 1.
4. Frame the SHeader, which includes signing and possibly encrypting it.
5. Construct SCommit using the framed SHeader and the SUpdatePath.

A projection of SCommit for a given receiver is constructed as follows:

1. Copy the `sheader` from SCommit to IndividualCommit.
2. Add to IndividualCommit `encrypted_path_secret` set to the ciphertext from
   `path` in SCommit that the receiver will use in Section 7.5 of {{!RFC9420}}.
3. Add to IndividualCommit `new_pks` set to those HPKE public keys from `path`
   in SCommit for which the receiver will not derive secret keys in Section 7.5
   of {{!RFC9420}}.

Steps 2 and 3 above can be easily performed with the knowledge of the ratchet
tree (by the DS or the committer).
{{delivering-scommits-without-the-ratchet-tree}} considers DS's that do not
know the ratchet tree.

A receiver group member processes an IndividualCommit using the following steps:

1. Unframe the `sheader`.
2. Use `sheader`, public keys from `path` and `proposals` to process the
   commit as specified in {{!RFC9420}}.
3. Verify that `epoch_identifier` in matches the secret exported
   from the new epoch with the label "SplittableCommit".


# Transcript Hashes

Section 8.2 of {{!RFC9420}} defines confirmed and interim trnscript hashes. The
input to the confirmed transcript hash is the FramedContent containing the
commit and the signature on it, while the interim transcript hash also contains
the confirmation tag.

The extension defined in this document simplifies this mechanism as follows. The
input to the confirmed transcript hash is the FramedContent containing the
SHeader with empty `epoch_identifier`. The confirmation tag is not used.


# Delivering SCommits without the Ratchet Tree

If the DS does not know the new epoch's ratchet tree, then it cannot determine
which ciphertexts and public keys to deliver to which members. Fortunately, if
the SCommit does not include an SUpdatePath then there's no need to convert it
as nothing needs to be filtered out for any receiver.

In general, there are several ways to help third parties split commits into
IndividualCommits even without knowing the new epoch's ratchet tree.
For example, the sender can annotate the ciphertexts in the SCommit.
Alternatively, the receiver can "pull" the SCommit without `path`, identify the
sender and indicate the index of the ciphertext it expects before pulling it.
Further exploration of this case is outside the scope of this document.

# Security Considerations

## Transcript Hashes

Compared to the transcript hash defined in this extension, the transcript hash
in {{!RFC9420}} contains the following additional information: all new HPKE keys
on the committer's direct path, all HPKE ciphertexts the committer generates,
the signature on the commit and the confirmation tag. We argue that this
additional information does not contribute to MLS's security.

The goal of the transcript hash is to provide agreement on the group's history.
Technically, this is achieved by feeding the transcript hash into the key
schedule derivation. Agreeing on the exact bytes of the HPKE ciphertexts and the
signature is not required for MLS's security. Instead, it is sufficent for group
members to only agree on the *plaintexts* in the ciphertexts and the new HPKE
keys on the committer's path. Fortunately, that information is already fed into
key schedule derivation outside of the transcript hash. This is because the key
schedule includes the `commit_secret` (which binds the plaintexts) and the
`tree_hash` of the new epoch (which binds the new HPKE keys).

We also note that MLS's transcript hash does not bind the full transcript. For
example, if a commit is framed as a PrivateMessage, then a random reuse guard
and (possibly random) padding are included in the PrivateMessage but not in the
transcript hash.


## Authenticating and Encrypting Split Commits

Both in an SCommit and in a IndividualCommit, the SHeader objects are
signed and encrypted, while SUpdatePath and IndividualUpdatePath are not. This
lack of encryption compared to MLS is not a problem because the SUpdatePath
doesn't contain secrets (only public keys and ciphertexts). The (more
sensetive) proposals and LeafNode are encrypted as part of the
SHeader.

The lack of signature (and MAC) for an SUpdatePath stems from the fact that
members receive IndividualCommit messages with different parts
of the original SUpdatePath object. Without the missing parts of SUPdatePath
they can not verify any signature (or MAC) over the full object. If instead,
a signature (or MAC) covering the IndividualUpdatePath then it becomes
impossible for third parties (such as the DS) to convert an SCommit into an
IndividualCommit.

Fortunately, authenticating just the SHeader part does suffice to
still ensure the same security for splittable commits as provided by a
regular MLS commits.

In MLS, commiters sign the confirmation tag (and the receivers recomputing them
to check the signature). This serves two purposes. First, it forces the sender
to demonstrate knowledge of the new epoch's key schedule to receivers
(preventing attacks where a commit is somehow manipulated while in transit by
an adversary knowing only the sender's signing key). Second, it ensures all
receivers that accept a given commit will always agree on any application
relevant properties about the new epoch.

SCommits enjoy the same two properties by signing SHeader and
using epoch identifiers in place of confirmation tags. A confirmation tag in
MLS the confirmation binds everything about `path` (including the ciphertexts)
because `path` is fed into the new key schedule (via the transcript hash).
However, MLS only does this as way to get confirmation tags to bind the
*plaintexts* and public keys in `path`. (Since MLS does not use key-committing
encryption for payloads it also binds the keys used for decryption in the
confirmation tag.) Luckily, for an SCommit, An epoch identifier does bind those
values. After all, the identifier is derived from the new key schedule which is
derived (in part) from the previous `commit_secret` which binds the plaintexts
in `path`. Further, the new key schedule is also derived from the epoch's
`tree_hash` and that (together with the previous epoch's `tree_hash` which is
also in the derivation path) binds the new public keys in `path`.


# IANA Considerations

This document has no IANA actions.


--- back

# Acknowledgments
{:numbered="false"}

TODO acknowledge.
